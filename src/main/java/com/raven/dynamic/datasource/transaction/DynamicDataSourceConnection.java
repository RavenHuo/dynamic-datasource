package com.raven.dynamic.datasource.transaction;

import com.raven.dynamic.datasource.config.DynamicDataSource;
import com.raven.dynamic.datasource.transaction.call.ForceExecuteCallback;
import com.raven.dynamic.datasource.transaction.call.ForceExecuteTemplate;
import com.raven.dynamic.datasource.transaction.statement.DynamicDataSourcePreparedStatement;
import com.raven.dynamic.datasource.transaction.statement.DynamicDataSourceStatement;
import lombok.extern.slf4j.Slf4j;

import java.sql.*;

/**
 * @description:
 * @author: huorw
 * @create: 2021-01-20 22:44
 */
@Slf4j
public class DynamicDataSourceConnection extends AbstractUnsupportedOperationConnection {

    private DynamicDataSource dynamicDataSource;

    private ForceExecuteTemplate<ConnectionProxy> forceExecuteTemplate = new ForceExecuteTemplate<>();

    private boolean autoCommit = true;

    private boolean readOnly = true;

    private boolean closed = false;

    private int transactionIsolation = TRANSACTION_READ_UNCOMMITTED;

    public DynamicDataSourceConnection(DynamicDataSource dynamicDataSource) {
        this.dynamicDataSource = dynamicDataSource;
    }

    @Override
    public Statement createStatement() throws SQLException {

        return new DynamicDataSourceStatement(dynamicDataSource);
    }

    @Override
    public PreparedStatement prepareStatement(String sql) throws SQLException {
        return new DynamicDataSourcePreparedStatement(dynamicDataSource, sql);
    }

    @Override
    public void setAutoCommit(boolean autoCommit) throws SQLException {
        this.autoCommit = autoCommit;
        forceExecuteTemplate.execute(ConnectionFactory.getConnectionList(), new ForceExecuteCallback<ConnectionProxy>() {
            @Override
            public void execute(ConnectionProxy target) throws SQLException {
                target.setAutoCommit(autoCommit);
            }
        });
    }

    @Override
    public boolean getAutoCommit() throws SQLException {
        return autoCommit;
    }

    @Override
    public void commit() throws SQLException {
        //
    }

    @Override
    public void rollback() throws SQLException {
        //
    }

    @Override
    public void close() throws SQLException {
        //
    }

    @Override
    public boolean isClosed() throws SQLException {
        return closed;
    }

    @Override
    public DatabaseMetaData getMetaData() throws SQLException {
        return ConnectionFactory.getConnectionProxy(dynamicDataSource).getMetaData();
    }

    @Override
    public void setReadOnly(boolean readOnly) throws SQLException {
        this.readOnly = readOnly;
    }

    @Override
    public boolean isReadOnly() throws SQLException {
        return readOnly;
    }

    @Override
    public void setTransactionIsolation(int level) throws SQLException {
        this.transactionIsolation = level;
        forceExecuteTemplate.execute(ConnectionFactory.getConnectionList(), new ForceExecuteCallback<ConnectionProxy>() {
            @Override
            public void execute(ConnectionProxy target) throws SQLException {
                target.setTransactionIsolation(level);
            }
        });
    }

    @Override
    public int getTransactionIsolation() throws SQLException {
        return transactionIsolation;
    }


    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException {
        return new DynamicDataSourceStatement(dynamicDataSource, resultSetType, resultSetConcurrency);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency) throws SQLException {
        return new DynamicDataSourcePreparedStatement(dynamicDataSource, sql, resultSetType, resultSetConcurrency);
    }


    @Override
    public Statement createStatement(int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return new DynamicDataSourceStatement(dynamicDataSource, resultSetType, resultSetConcurrency);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        return new DynamicDataSourcePreparedStatement(dynamicDataSource, sql, resultSetType, resultSetConcurrency, resultSetHoldability);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
        return new DynamicDataSourcePreparedStatement(dynamicDataSource, sql, autoGeneratedKeys);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLException {
        return new DynamicDataSourcePreparedStatement(dynamicDataSource, sql, columnIndexes);
    }

    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLException {
        return new DynamicDataSourcePreparedStatement(dynamicDataSource, sql, columnNames);
    }

    @Override
    public final CallableStatement prepareCall(final String sql) throws SQLException {
        throw new SQLFeatureNotSupportedException("prepareCall");
    }

    @Override
    public final CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency) throws SQLException {
        throw new SQLFeatureNotSupportedException("prepareCall");
    }

    @Override
    public final CallableStatement prepareCall(final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) throws SQLException {
        throw new SQLFeatureNotSupportedException("prepareCall");
    }

    //////////////////////////////////////

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {

    }
    @Override
    public void setHoldability(int holdability) throws SQLException {

    }

    @Override
    public int getHoldability() throws SQLException {
        return 0;
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        return ConnectionFactory.getConnectionProxy(dynamicDataSource).unwrap(iface);
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return ConnectionFactory.getConnectionProxy(dynamicDataSource).isWrapperFor(iface);
    }
}
